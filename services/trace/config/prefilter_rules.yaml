# Pre-filter rules for tool routing (CB-38).
# Narrows 55+ tools to 5-10 candidates before the LLM router classifies.
# See tickets/planned/cb_38_prefilter_tool_routing.md for design.

enabled: true
min_candidates: 3
max_candidates: 10
negation_proximity: 3
always_include:
  - answer

forced_mappings:
  - patterns:
      - "call chain from"
      - "call chain of"
      - "full call hierarchy"
      - "transitive callers"
      - "transitive callees"
    tool: get_call_chain
    reason: "Explicit call chain request"

  - patterns:
      - "shortest path between"
      - "path from .* to"
    tool: find_path
    reason: "Path query is unambiguous"

  # GR-61 Option L: Intent templates for reference vs symbol disambiguation.
  #
  # Ordering constraint: Phase 1 (forced mappings) fires BEFORE Phase 2
  # (negation detection). Patterns here must therefore be structurally
  # specific enough that they cannot appear in negated form in practice.
  #
  # Design choice: broad patterns like "where is .* referenced" are
  # intentionally EXCLUDED because they would match "where is X not
  # referenced" before the negation phase fires — wrongly forcing
  # find_references when find_dead_code is correct.
  #
  # Go regexp uses RE2, which does NOT support lookaheads (?!...) or \b.
  # The specificity of the prepositional phrase ("across", "in", "throughout")
  # is the negation guard: these phrases are not idiomatic with negation.
  - patterns:
      - "where is .* referenced across"
      - "where is .* referenced in"
      - "where is .* referenced throughout"
      - "how is .* referenced"
      - "find all references to"
      - "referenced across the codebase"
      - "referenced throughout"
      - "all usages of"
      - "all uses of"
    tool: find_references
    reason: "Passive-voice reference query with prepositional context — subject is being referenced"

  - patterns:
      - "where is .* defined"
      - "where is .* declared"
      - "where is it defined"
      - "find the definition of"
      - "locate the .* definition"
    tool: find_symbol
    reason: "Definition lookup — asking for declaration site, not call sites"

  - patterns:
      - "what calls .*"
      - "who calls .*"
      - "what invokes .*"
      - "who invokes .*"
    tool: find_callers
    reason: "Active-voice caller query — subject is the callee, looking for callers"

  - patterns:
      - "what does .* call"
      - "what does .* invoke"
      - "what functions does .* call"
      - "what methods does .* call"
    tool: find_callees
    reason: "Callee/dependency query — subject is the caller, looking for callees"

negation_rules:
  - negation_words: ["no", "not", "never", "zero", "without"]
    trigger_keywords: ["callers", "incoming calls", "called", "referenced"]
    wrong_tool: find_callers
    correct_tool: find_dead_code
    action: force
    reason: "Negated caller = dead code"

  - negation_words: ["no", "not", "never", "zero"]
    trigger_keywords: ["references", "usages", "uses"]
    wrong_tool: find_references
    correct_tool: find_dead_code
    action: force
    reason: "Negated reference = unreferenced code"

confusion_pairs:
  - tool_a: find_callers
    tool_b: find_callees
    tool_a_patterns:
      - "who calls"
      - "what calls"
      - "callers of"
      - "call sites for"
    tool_b_patterns:
      - "what does .* call"
      - "what functions does"
      - "dependencies of"
    boost_amount: 3.0

  - tool_a: find_callers
    tool_b: find_references
    tool_a_patterns:
      - "who calls"
      - "what calls"
      - "call sites"
    tool_b_patterns:
      - "where is .* used"
      - "references to"
      - "usages of"
      - "find all uses"
    boost_amount: 3.0

  - tool_a: find_hotspots
    tool_b: find_weighted_criticality
    tool_a_patterns:
      - "most connected"
      - "coupling"
      - "fan-in"
      - "fan-out"
      - "hotspot"
    tool_b_patterns:
      - "most critical"
      - "highest risk"
      - "would break"
      - "stability"
    boost_amount: 3.0

  - tool_a: find_cycles
    tool_b: find_circular_deps
    tool_a_patterns:
      - "function cycles"
      - "call cycles"
      - "mutual recursion"
    tool_b_patterns:
      - "circular dependencies"
      - "package cycles"
      - "dependency cycle"
    boost_amount: 2.0

  # IT-11: "bridges between communities" → find_communities, not find_articulation_points
  - tool_a: find_communities
    tool_b: find_articulation_points
    tool_a_patterns:
      - "communit"
      - "code cluster"
      - "module boundar"
      - "leiden"
    tool_b_patterns:
      - "single point of failure"
      - "fragil"
      - "cut vert"
      - "bus factor"
    boost_amount: 3.0
